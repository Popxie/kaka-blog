<!--
 * @Description: js文件夹
 * @Author: xiehuaqiang
 * @FilePath: /kaka-blog/src/docs/kaka/js/未公开/如何避免内存泄漏.md
 * @Date: 2022-01-04 12:52:51
 * @LastEditTime: 2022-01-04 13:04:30
-->

# 如何避免内存泄漏

## 1.尽可能少地创建全局变量

在 ES5 中以 `var` 声明的方式在全局作用域中创建一个变量时，或者在函数作用域中不以任何声明的方式创建一个变量时，都会无形地挂载到 `window` 全局对象上，如下所示：

```js
var a = 1 // 等价于 window.a = 1;

function foo() {
  a = 1
}
```

等价于

```js
function foo() {
  window.a = 1
}
```

我们在 `foo` 函数中创建了一个变量 `a` 但是忘记使用 `var` 来声明，此时会意想不到地创建一个全局变量并挂载到 `window` 对象上，另外还有一种比较隐蔽的方式来创建全局变量：

```js
function foo() {
  this.a = 1
}
foo() // 相当于 window.foo()
```

当 `foo` 函数在调用时，它所指向的运行上下文环境为 `window` 全局对象，因此函数中的 this 指向的其实是 `window`，也就无意创建了一个全局变量。当进行垃圾回收时，在标记阶段因为 `window` 对象可以作为根节点，在 `window` 上挂载的属性均可以被访问到，并将其标记为活动的从而常驻内存，因此也就不会被垃圾回收，只有在整个进程退出时全局作用域才会被销毁。如果你遇到需要必须使用全局变量的场景，那么请保证一定要在全局变量使用完毕后将其设置为 `null` 从而触发回收机制。

## 2.手动清除定时器

在我们的应用中经常会有使用 `setTimeout` 或者 `setInterval` 等定时器的场景，定时器本身是一个非常有用的功能，但是如果我们稍不注意，忘记在适当的时间手动清除定时器，那么很有可能就会导致内存泄漏，示例如下：

```js
const numbers = []
const foo = function () {
  for (let i = 0; i < 100000; i++) {
    numbers.push(i)
  }
}
window.setInterval(foo, 1000)
```

在这个示例中，由于我们没有手动清除定时器，导致回调任务会不断地执行下去，回调中所引用的 numbers 变量也不会被垃圾回收，最终导致 numbers 数组长度无限递增，从而引发内存泄漏。

## 3.少用闭包

闭包是 JS 中的一个高级特性，巧妙地利用闭包可以帮助我们实现很多高级功能。一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：

```js
function foo() {
  let local = 123
  return function () {
    return local
  }
}
const bar = foo()
console.log(bar()) // -> 123
```

在这个示例中，`foo` 函数执行完毕后会返回一个匿名函数，该函数内部引用了 `foo` 函数中的局部变量 `local`，并且通过变量 bar 来引用这个匿名的函数定义，通过这种闭包的方式我们就可以在 `foo` 函数的外部作用域中访问到它的局部变量 `local`。一般情况下，当 `foo` 函数执行完毕后，它的作用域会被销毁，但是由于存在变量引用其返回的匿名函数，导致作用域无法得到释放，也就导致 `local` 变量无法回收，只有当我们取消掉对匿名函数的引用才会进入垃圾回收阶段。

## 4.清除 DOM 引用

以往我们在操作 `DOM` 元素时，为了避免多次获取 `DOM` 元素，我们会将 `DOM` 元素存储在一个数据字典中，示例如下：

```js
const elements = {
  button: document.getElementById('button')
}

function removeButton() {
  document.body.removeChild(document.getElementById('button'))
}
```

在这个示例中，我们想调用 `removeButton` 方法来清除 `button` 元素，但是由于在 `elements` 字典中存在对 `button` 元素的引用，所以即使我们通过 `removeChild` 方法移除了 `button` 元素，它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对 `button` 元素的引用才会被垃圾回收。

## 5.弱引用

通过前几个示例我们会发现如果我们一旦疏忽，就会容易地引发内存泄漏的问题，为此，在 `ES6` 中为我们新增了两个有效的数据结构 `WeakMap` 和 `WeakSet`，就是为了解决内存泄漏的问题而诞生的。其表示弱引用，它的键名所引用的对象均是弱引用，弱引用是指垃圾回收的过程中不会将键名对该对象的引用考虑进去，只要所引用的对象没有其他的引用了，垃圾回收机制就会释放该对象所占用的内存。这也就意味着我们不需要关心 `WeakMap` 中键名对其他对象的引用，也不需要手动地进行引用清除，

[阅读原文·掘金·一文搞懂 V8 引擎的垃圾回收](https://juejin.cn/post/6844904016325902344#)
