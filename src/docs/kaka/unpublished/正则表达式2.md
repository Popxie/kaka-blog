<!--
 * @Description: 日常笔记文件夹
 * @Author: xiehuaqiang
 * @FilePath: /kaka-blog/src/docs/kaka/unpublished/正则表达式2.md
 * @Date: 2021-03-15 20:50:07
 * @LastEditTime: 2021-06-17 20:53:37
-->

# 正则表达式 2

## 主要元字符

### **`.`**

匹配除换行符`\n`外的任意字符，如果要匹配任意字符，应该用`/[.\n]*/`。

### **`\s`**

匹配任意空字符，包括空格，制表符 `\t`，垂直制表符`\v`，换行符`\n`，回车符`\r`，换页符`\f`。`\s`等价于`[ \t\v\n\r\f`]，注意方括号内第一个位置有空格。

这里也说下换行符和回车符的区别：

- 换行符\n：光标下移一行，不回行首。
- 回车符\r：光标回到行首，不换行。

### **`\S`**

`\S`是`\s`的反集 ，利用`\s`和`\S`的这种互为反集的关系，我们就可以匹配任意字符，写法如下：

```js
;/[\s\S]/
```

### **`\d`**

`\d`用于匹配数字，等价于`[0-9]`

### **`\D`**

`\D`是`\d`的反集，也就是匹配非数字，等价于[^0-9]`

### **`\w`**

\w 用于匹配单词字符，包含`0-9`，`a-z`，`A-z`以及下划线`_`，等价于`[A-Za-z0-9_]`。

### **`\W`**

`\W`是`\w`的反集，用于匹配非单词字符，等价于`[^A-Za-z0-9_]`

### **`\n`**

`\n`是开发中经常遇到的换行符，而上面提到的`\s`是包含`\n`在内的。所以，能被`\n`匹配的字符，也一定能被`\s`匹配。

### **`\b`**

`\b`用于匹配单词的边界，即单词的开始或结束。

一开始其实我不太能理解`\b`在正则表达式中的作用。

直到我自己试了一下这个案例

```js
'I love you'.match(/love/)
'Iloveyou'.match(/love/)
```

这两个表达式都能匹配到结果`"love"`。

但是有时候我们并不希望这样的字符串`'Iloveyou'`被匹配，因为它没有单词间的空格。

所以\b 有了它存在的意义。看下面的例子：

```js
'I love you'.match(/\blove\b/)
'Iloveyou'.match(/\blove\b/) // null
```

第一个表达式仍然可以正常匹配到结果，而第二个就无法匹配到结果了，这符合我们的预期。

有的人可能会说，那我可以用空格匹配啊。

```js
'I love you'.match(/ love /)
```

空格和`\b`在这种场景下还是有一点不一样的，这体现在 `match` 的结果上。

如果是用空格匹配，那么 `match` 的结果数组中的第一项就是`" love "`，是带了空格的，然而很多时候我们不希望在结果中得到空格，所以`\b` 存在的意义也就比较明显了。

## 量词

匹配前面的子表达式零次或一次

### **`?`**

匹配前面的子表达式零次或一次

### **`+`**

匹配前面的子表达式一次或多次

### **`*`**

匹配前面的子表达式零次或任意次

### **`{n,m}`**

匹配前一个普通字符或者子表达式最少 n 次，最多 m 次

### **`{n,}`**

匹配前一个普通字符或者子表达式最少 n 次

### **`{n}`**

匹配前一个普通字符或者子表达式 n 次

### **`贪婪`**

贪婪匹配是尽可能多地匹配，如果能满足匹配条件，就尽可能侵占后面的匹配规则。

贪婪匹配是默认的，比如`/\d?/`会尽可能地匹配 `1` 个数字，`/\d+/`和`/\d*/`会尽可能地匹配多个数字。

举个例子，

```js
'123456789'.match(/^(\d+)(\d{2,})$/)
```

以上结果中捕获组的第一项是`"1234567"`，第二项是`"89"`。

为什么会这样呢？因为`\d+`是贪婪匹配，尽可能地多匹配，如果没有后面的`\d{2,}`，捕获组第一项会直接是"123456789"。但是由于`\d{2,}`的存在，`\d+`会给`\d{2,}`留个面子，满足它的最小条件，即匹配 2 个数字，而`\d+`自己匹配 7 个数字。

### **`非贪婪`**

非贪婪匹配是尽可能少地匹配，一般是在量词`?`, `+`, `*`之后再加一个`?`，表示尽可能少地匹配，把机会留给后面的匹配规则。

还是拿贪婪模式中那个例子举例，稍微改一下，`\d+`换成非贪婪模式`\d+?`。

```js
'123456789'.match(/^(\d+?)(\d{2,})$/)
```

捕获组的第一项是`"1"`，第二项变成了`"23456789"`。

为什么会这样呢？因为在非贪婪模式下，会尽可能少匹配，把机会留给后面的匹配规则。

## 分组

[阅读原文](https://mp.weixin.qq.com/s/dZu_S8IPTFsLUuYk72XtSw)
