(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d2306c1"],{ebe3:function(e,t,s){"use strict";s.r(t);var r=s("2877"),a=Object(r.a)({},(function(){var e=this;e.$createElement;return e._self._c,e._m(0)}),[function(){var e=this,t=e.$createElement,s=e._self._c||t;return s("section",[s("html",[s("head"),s("body",[s("h1",[e._v("Git 内部原理之 Git 引用")]),s("p",[e._v("首先来搞清楚什么是 Git 引用，前文讲了 Git 提交对象的哈希、存储原理，理论上我们只要知道该对象的 hash 值，就能往前推出整个提交历史，例如：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("log")]),e._v(" --pretty=oneline 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 third commit\nd4d2c6cffb408d978cb6f1eb6cfc70e977378a5c second commit\ndb1d6f137952f2b24e3c85724ebd7528587a067a first commit\n")])]),s("p",[e._v("现在问题来了，提交对象的这 40 位 hash 值不好记忆，Git 引用相当于给 40 位 hash 值取一个别名，便于识别和读取。Git 引用对象都存储在 "),s("code",{pre:!0},[e._v(".git/refs")]),e._v(" 目录下，该目录下有 3 个子文件夹 heads、tags 和 remotes，分别对应于 HEAD 引用、标签引用和远程引用，下面分别讲一讲每种引用的原理。")]),s("h2",[e._v("HEAD 引用")]),s("p",[e._v("HEAD 引用是用来指向每个分支的最后一次提交对象，这样切换到一个分支之后，才能知道分支的“尾巴”在哪里。HEAD 引用存储在 "),s("code",{pre:!0},[e._v(".git/refs/heads")]),e._v(" 目录下，有多少个分支，就有相应的同名 HEAD 引用对象。例如代码库里面有 "),s("code",{pre:!0},[e._v("master")]),e._v(" 和 "),s("code",{pre:!0},[e._v("test")]),e._v(" 两个分支，那么 "),s("code",{pre:!0},[e._v(".git/refs/heads")]),e._v(" 目录下就存在 "),s("code",{pre:!0},[e._v("master")]),e._v(" 和 "),s("code",{pre:!0},[e._v("test")]),e._v(" 两个文件，分别记录了分支的最后一次提交。")]),s("p",[s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用的内容就是提交对象的 "),s("code",{pre:!0},[e._v("hash")]),e._v(" 值，理论上我们可以手动地构造一个 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),s("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"3ac728ac62f0a7b5ac201fd3ed1f69165df8be31"')]),e._v(" > .git/refs/heads/master\n")])]),s("p",[e._v("Git 提供了一个专有命令 "),s("code",{pre:!0},[e._v("update-ref")]),e._v("，用来查看和修改 Git 引用对象，当然也包括 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git update-ref refs/heads/master 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n$ git update-ref refs/heads/master\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n")])]),s("p",[e._v("上面的命令我们将 "),s("code",{pre:!0},[e._v("master")]),e._v(" 分支的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 指向了 "),s("code",{pre:!0},[e._v("3ac728ac62f0a7b5ac201fd3ed1f69165df8be31")]),e._v("，现在用 "),s("code",{pre:!0},[e._v("git log")]),e._v(" 查看下 "),s("code",{pre:!0},[e._v("master")]),e._v(" 的提交历史，可以发现最后一次提交就是所更新的 "),s("code",{pre:!0},[e._v("hash")]),e._v(" 值：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("log")]),e._v(" --pretty=oneline master\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 (HEAD -> master) third commit\nd4d2c6cffb408d978cb6f1eb6cfc70e977378a5c second commit\ndb1d6f137952f2b24e3c85724ebd7528587a067a first commit\n")])]),s("p",[e._v("同理，可以使用同样的方法更新 "),s("code",{pre:!0},[e._v("test")]),e._v(" 分支的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v("：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git update-ref refs/heads/test d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\n$ git "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("log")]),e._v(" --pretty=oneline "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("test")]),e._v("\nd4d2c6cffb408d978cb6f1eb6cfc70e977378a5c ("),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("test")]),e._v(") second commit\ndb1d6f137952f2b24e3c85724ebd7528587a067a first commit\n")])]),s("p",[s("code",{pre:!0},[e._v(".git/refs/heads")]),e._v(" 目录下存储了每个分支的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v("，那怎么知道代码库当前处于哪个分支呢？这就需要一个代码库级别的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用。"),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 这个文件就是整个代码库级别的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用。我们先查看一下 "),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 文件的内容：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/HEAD\nref: refs/heads/master\n")])]),s("p",[e._v("我们发现 "),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 文件的内容不是 40 位 "),s("code",{pre:!0},[e._v("hash")]),e._v(" 值，而像是指向 "),s("code",{pre:!0},[e._v(".git/refs/heads/master")]),e._v("。尝试切换到 "),s("code",{pre:!0},[e._v("test")]),e._v("：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git checkout "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("test")]),e._v("\n$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/HEAD\nref: refs/heads/test\n")])]),s("p",[e._v("切换分支后，"),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 文件的内容也跟着指向 "),s("code",{pre:!0},[e._v(".git/refs/heads/test")]),e._v("。"),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 也是 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用对象，与一般引用不同的是，它是“符号引用”。符号引用类似于文件的快捷方式，链接到要引用的对象上。")]),s("p",[s("code",{pre:!0},[e._v("Git")]),e._v(" 提供专门的命令 "),s("code",{pre:!0},[e._v("git symbolic-ref")]),e._v(" ，用来查看和更新符号引用：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git symbolic-ref HEAD refs/heads/master\n$ git symbolic-ref HEAD refs/heads/test\n")])]),s("p",[e._v("至此，我们分析了两种 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用，一种是分支级别的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用，用来记录各分支的最后一次提交，存储在."),s("code",{pre:!0},[e._v("git/refs/heads")]),e._v(" 目录下，使用 "),s("code",{pre:!0},[e._v("git update-ref")]),e._v(" 来维护；一种是代码库级别的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用，用来记录代码库所处的分支，存储在 "),s("code",{pre:!0},[e._v(".git/HEAD")]),e._v(" 文件，使用 "),s("code",{pre:!0},[e._v("git symbolic-ref")]),e._v(" 来维护。")]),s("h2",[e._v("标签引用")]),s("p",[e._v("标签引用，顾名思义就是给 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 对象打标签，便于记忆。例如，我们可以将某个提交对象打 v1.0 标签，表示是 1.0 版本。标签引用都存储在 "),s("code",{pre:!0},[e._v(".git/refs/tags")]),e._v(" 里面。")]),s("p",[e._v("标签引用和 "),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用本质是 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 引用对象，同样使用 "),s("code",{pre:!0},[e._v("git update-ref")]),e._v(" 来查看和修改：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git update-ref refs/tags/v1.0 d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\n$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/refs/tags/v1.0\nd4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\n")])]),s("p",[e._v("还有一种标签引用称为“附注引用”，可以为标签添加说明信息。上面的标签引用打了一个 v1.0 的标签表示发布 1.0 版本，有时候发布软件的时候除了版本号信息，还要写更新说明。附注引用就是用来实现打标签的同时，也可以附带说明信息。")]),s("p",[e._v("附注引用是怎么实现的呢？与常规标签引用不同的是，它不直接指向提交对象，而是新建一个 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 对象存储到 "),s("code",{pre:!0},[e._v(".git/objects")]),e._v(" 中，用来记录附注信息，然后附注标签指向这个 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 对象。")]),s("p",[e._v("使用 "),s("code",{pre:!0},[e._v("git tag")]),e._v(" 建立一个附注标签：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git tag -a v1.1 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31 -m "),s("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v('"test tag"')]),e._v("\n$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/refs/tags/v1.1\n8be4d8e4e8e80711dd7bae304ccfa63b35a6eb8c\n")])]),s("p",[e._v("使用 git "),s("code",{pre:!0},[e._v("cat-file")]),e._v(" 来查看附注标签所指向的 Git 对象：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p 8be4d8e4e8e80711dd7bae304ccfa63b35a6eb8c\nobject 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n"),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("type")]),e._v(" commit\ntag v1.1\ntagger jingsam <jing-sam@qq.com> 1529481368 +0800\n\n"),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("test")]),e._v(" tag\n")])]),s("p",[e._v("可以看到，上面的 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 对象存储了我们填写的附注信息。")]),s("p",[e._v("总之，普通的标签引用和附注引用同样都是存储的是 40 位 "),s("code",{pre:!0},[e._v("hash")]),e._v(" 值，指向一个 Git 对象，所不同的是普通的标签引用是直接指向提交对象，而附注标签是指向一个附注对象，附注对象再指向具体的提交对象。")]),s("p",[e._v("另外，本质上标签引用并不是只可以指向提交对象，实际上可以指向任何 Git 对象，即可以给任何 Git 对象打标签。")]),s("h2",[e._v("远程引用")]),s("p",[e._v("远程引用，类似于 "),s("code",{pre:!0},[e._v(".git/refs/heads")]),e._v(" 中存储的本地仓库各分支的最后一次提交，在 "),s("code",{pre:!0},[e._v(".git/refs/remotes")]),e._v(" 是用来记录多个远程仓库各分支的最后一次提交。")]),s("p",[e._v("我们可以使用 "),s("code",{pre:!0},[e._v("git remote")]),e._v(" 来管理远程分支：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git remote add origin git@github.com:jingsam/git-test.git\n")])]),s("p",[e._v("上面添加了一个 "),s("code",{pre:!0},[e._v("origin")]),e._v(" 远程分支，接下来我们把本地仓库的 "),s("code",{pre:!0},[e._v("master")]),e._v(" 推送到远程仓库上：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git push origin master\nCounting objects: 9, "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("done")]),e._v(".\nDelta compression using up to 4 threads.\nCompressing objects: 100% (5/5), "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("done")]),e._v(".\nWriting objects: 100% (9/9), 720 bytes | 360.00 KiB/s, "),s("span",{pre:!0,attrs:{class:"hljs-keyword"}},[e._v("done")]),e._v(".\nTotal 9 (delta 0), reused 0 (delta 0)\nTo github.com:jingsam/git-test.git\n * [new branch]      master -> master\n")])]),s("p",[e._v("这时候在 "),s("code",{pre:!0},[e._v(".git/refs/remotes")]),e._v(" 中的远程引用就会更新：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/refs/remotes/origin/master\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n")])]),s("p",[e._v("和本地仓库的 "),s("code",{pre:!0},[e._v("master")]),e._v(" 比较一下，发现是一模一样的，表示远程分支和本地分支是同步的：")]),s("pre",{pre:!0},[s("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),s("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cat")]),e._v(" .git/refs/heads/master\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n")])]),s("p",[e._v("由于远程引用也是 "),s("code",{pre:!0},[e._v("Git")]),e._v(" 引用对象，所以理论上也可以使用 "),s("code",{pre:!0},[e._v("git update-ref")]),e._v(" 来手动维护。但是，我们需要先把代码与远程仓库进行同步，在远程仓库中找到对应分支的 "),s("code",{pre:!0},[e._v("HEAD")]),e._v("，然后使用 "),s("code",{pre:!0},[e._v("git update-ref")]),e._v(" 进行更新，过程比较麻烦。而我们在执行 "),s("code",{pre:!0},[e._v("git pull")]),e._v(" 或 "),s("code",{pre:!0},[e._v("git push")]),e._v(" 这样的高层命令的时候，远程引用会自动更新。")]),s("h2",[e._v("总结")]),s("p",[e._v("到这里，三种 Git 引用都已分析完毕。总的来说，三种 Git 引用都统一存储到 "),s("code",{pre:!0},[e._v(".git/refs")]),e._v(" 目录下，Git 引用中的内容都是 40 位的 "),s("code",{pre:!0},[e._v("hash")]),e._v(" 值，指向某个 Git 对象，这个对象可以是任意的 Git 对象，可以是"),s("code",{pre:!0},[e._v("数据对象")]),e._v("、"),s("code",{pre:!0},[e._v("树对象")]),e._v("、"),s("code",{pre:!0},[e._v("提交对象")]),e._v("。三种 Git 引用都可以使用 "),s("code",{pre:!0},[e._v("git update-ref")]),e._v(" 来手动维护。")]),s("p",[e._v("三种 Git 引用对象所不同的是，分别存储于"),s("code",{pre:!0},[e._v(".git/refs/heads")]),e._v("、"),s("code",{pre:!0},[e._v(".git/refs/tags")]),e._v("、"),s("code",{pre:!0},[e._v(".git/refs/remotes")]),e._v(",存储的文件夹不同，赋予了引用对象不同的功能。"),s("code",{pre:!0},[e._v("HEAD")]),e._v(" 引用用来记录本地分支的最后一次提交，标签引用用来给任意 Git 对象打标签，远程引用正式用来记录远程分支的最后一次提交。")]),s("p",[s("a",{attrs:{href:"https://jingsam.github.io/2018/10/12/git-reference.html"}},[e._v("阅读原文")])])])])])}],!1,null,null,null);t.default=a.exports}}]);