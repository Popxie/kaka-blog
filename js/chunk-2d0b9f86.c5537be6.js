(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d0b9f86"],{"34e4":function(s,t,a){"use strict";a.r(t);var _=a("2877"),e=Object(_.a)({},(function(){var s=this;s.$createElement;return s._self._c,s._m(0)}),[function(){var s=this,t=s.$createElement,a=s._self._c||t;return a("section",[a("html",[a("head"),a("body",[a("h1",[s._v("你不懂JS: "),a("em",[s._v("this")]),s._v(" 与对象原型")]),a("h1",[s._v("第一章: "),a("code",{pre:!0},[s._v("this")]),s._v(" 是什么？")]),a("p",[s._v("JavaScript 中最令人困惑的机制之一就是 "),a("code",{pre:!0},[s._v("this")]),s._v(" 关键字。它是一个在每个函数作用域中自动定义的特殊标识符关键字，但即便是一些老练的 JavaScript 开发者也对它到底指向什么感到困扰。")]),a("blockquote",[a("p",[s._v("任何足够 "),a("em",[s._v("先进")]),s._v(" 的技术都跟魔法没有区别。-- Arthur C. Clarke")])]),a("p",[s._v("JavaScript 的 "),a("code",{pre:!0},[s._v("this")]),s._v(" 机制实际上没有 "),a("em",[s._v("那么")]),s._v(" 先进，但是开发者们总是在大脑中插入“复杂”和“混乱”来解释这句话，毫无疑问，如果没有清晰的理解，在 "),a("em",[s._v("你的")]),s._v(" 困惑中 "),a("code",{pre:!0},[s._v("this")]),s._v(" 可能看起来就是彻头彻尾的魔法。")]),a("p",[a("strong",[s._v("注意：")]),s._v(" “this”这个词是在一般的论述中极常用的代词。所以，特别是在口头论述中，很难确定我们是在将“this”作为一个代词使用，还是在将它作为一个实际的关键字标识符使用。为了表意清晰，我会总是使用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 来代表特殊的关键字，而在其他情况下使用“this”或 "),a("em",[s._v("this")]),s._v(" 或 this。")]),a("h2",[s._v("为什么要用 "),a("code",{pre:!0},[s._v("this")]),s._v("？")]),a("p",[s._v("如果对于那些老练的 JavaScript 开发者来说 "),a("code",{pre:!0},[s._v("this")]),s._v(" 机制都是如此的令人费解，那么有人会问为什么这种机制会有用？它带来的麻烦不是比好处多吗？在讲解 "),a("em",[s._v("如何")]),s._v(" 有用之前，我们应当先来看看 "),a("em",[s._v("为什么")]),s._v(" 有用。")]),a("p",[s._v("让我们试着展示一下 "),a("code",{pre:!0},[s._v("this")]),s._v(" 的动机和用途：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("identify")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("name")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("toUpperCase")]),s._v("();\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("speak")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" greeting = "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"Hello, I\'m "')]),s._v(" + identify."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v(" );\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( greeting );\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" me = {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("name")]),s._v(": "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"Kyle"')]),s._v("\n};\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" you = {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("name")]),s._v(": "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"Reader"')]),s._v("\n};\n\nidentify."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( me ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// KYLE")]),s._v("\nidentify."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( you ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// READER")]),s._v("\n\nspeak."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( me ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// Hello, I'm KYLE")]),s._v("\nspeak."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( you ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// Hello, I'm READER")]),s._v("\n")])]),a("p",[s._v("如果这个代码段 "),a("em",[s._v("如何")]),s._v(" 工作让你困惑，不要担心！我们很快就会讲解它。只是简要地将这些问题放在旁边，以便于我们可以更清晰的探究 "),a("em",[s._v("为什么")]),s._v("。")]),a("p",[s._v("这个代码片段允许 "),a("code",{pre:!0},[s._v("identify()")]),s._v(" 和 "),a("code",{pre:!0},[s._v("speak()")]),s._v(" 函数对多个 "),a("em",[s._v("环境")]),s._v(" 对象（"),a("code",{pre:!0},[s._v("me")]),s._v(" 和 "),a("code",{pre:!0},[s._v("you")]),s._v("）进行复用，而不是针对每个对象定义函数的分离版本。")]),a("p",[s._v("与使用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 相反地，你可以明确地将环境对象传递给 "),a("code",{pre:!0},[s._v("identify()")]),s._v(" 和 "),a("code",{pre:!0},[s._v("speak()")]),s._v("。")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("identify")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("context")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("return")]),s._v(" context."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("name")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("toUpperCase")]),s._v("();\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("speak")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("context")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" greeting = "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"Hello, I\'m "')]),s._v(" + "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("identify")]),s._v("( context );\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( greeting );\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("identify")]),s._v("( you ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// READER")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("speak")]),s._v("( me ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// Hello, I'm KYLE")]),s._v("\n")])]),a("p",[s._v("然而，"),a("code",{pre:!0},[s._v("this")]),s._v(" 机制提供了更优雅的方式来隐含地“传递”一个对象引用，导致更加干净的API设计和更容易的复用。")]),a("p",[s._v("你的使用模式越复杂，你就会越清晰地看到：将执行环境作为一个明确参数传递，通常比传递 "),a("code",{pre:!0},[s._v("this")]),s._v(" 执行环境要乱。当我们探索对象和原型时，你将会看到一组可以自动引用恰当执行环境对象的函数是多么有用。")]),a("h2",[s._v("困惑")]),a("p",[s._v("我们很快就要开始讲解 "),a("code",{pre:!0},[s._v("this")]),s._v(" 是如何 "),a("em",[s._v("实际")]),s._v(" 工作的，但我们首先要摒弃一些误解——它实际上 "),a("em",[s._v("不是")]),s._v(" 如何工作的。")]),a("p",[s._v("在开发者们用太过于字面的方式考虑“this”这个名字时就会产生困惑。这通常会产生两种臆测，但都是不对的。")]),a("h3",[s._v("它自己")]),a("p",[s._v("第一种常见的倾向是认为 "),a("code",{pre:!0},[s._v("this")]),s._v(" 指向函数自己。至少，这是一种语法上的合理推测。")]),a("p",[s._v("为什么你想要在函数内部引用它自己？最常见的理由是递归（在函数内部调用它自己）这样的情形，或者是一个在第一次被调用时会解除自己绑定的事件处理器。")]),a("p",[s._v("初次接触 JS 机制的开发者们通常认为，将函数作为一个对象（JavaScript 中所有的函数都是对象！），可以让你在方法调用之间储存 "),a("em",[s._v("状态")]),s._v("（属性中的值）。这当然是可能的，而且有一些有限的用处，但这本书的其余部分将会阐述许多其他的模式，提供比函数对象 "),a("em",[s._v("更好")]),s._v(" 的地方来存储状态。")]),a("p",[s._v("过一会儿我们将探索一个模式，来展示 "),a("code",{pre:!0},[s._v("this")]),s._v(" 是如何不让一个函数像我们可能假设的那样，得到它自身的引用的。")]),a("p",[s._v("考虑下面的代码，我们试图追踪函数("),a("code",{pre:!0},[s._v("foo")]),s._v(")被调用了多少次：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("num")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"foo: "')]),s._v(" + num );\n\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 追踪 `foo` 被调用了多少次")]),s._v("\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v("++;\n}\n\nfoo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" = "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v(";\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" i;\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("for")]),s._v(" (i="),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v("; i<"),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("10")]),s._v("; i++) {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" (i > "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("5")]),s._v(") {\n\t\t"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("( i );\n\t}\n}\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 6")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 7")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 8")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 9")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// `foo` 被调用了多少次？")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( foo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 0 -- 这他妈怎么回事……？")]),s._v("\n")])]),a("p",[a("code",{pre:!0},[s._v("foo.count")]),s._v(" "),a("em",[s._v("依然")]),s._v(" 是 "),a("code",{pre:!0},[s._v("0")]),s._v(", 即便四个 "),a("code",{pre:!0},[s._v("console.log")]),s._v(" 语句明明告诉我们 "),a("code",{pre:!0},[s._v("foo(..)")]),s._v(" 实际上被调用了四次。这种挫败来源于对于 "),a("code",{pre:!0},[s._v("this")]),s._v("（在 "),a("code",{pre:!0},[s._v("this.count++")]),s._v(" 中）的含义进行了 "),a("em",[s._v("过于字面化")]),s._v(" 的解释。")]),a("p",[s._v("当代码执行 "),a("code",{pre:!0},[s._v("foo.count = 0")]),s._v(" 时，它确实向函数对象 "),a("code",{pre:!0},[s._v("foo")]),s._v(" 添加了一个 "),a("code",{pre:!0},[s._v("count")]),s._v(" 属性。但是对于函数内部的 "),a("code",{pre:!0},[s._v("this.count")]),s._v(" 引用，"),a("code",{pre:!0},[s._v("this")]),s._v(" 其实 "),a("em",[s._v("根本就不")]),s._v(" 指向那个函数对象，即便属性名称一样，但根对象也不同，因而产生了混淆。")]),a("p",[a("strong",[s._v("注意：")]),s._v(" 一个负责任的开发者 "),a("em",[s._v("应当")]),s._v(" 在这里提出一个问题：“如果我递增的 "),a("code",{pre:!0},[s._v("count")]),s._v(" 属性不是我以为的那个，那是哪个 "),a("code",{pre:!0},[s._v("count")]),s._v(" 被我递增了？”。实际上，如果他再挖的深一些，他会发现自己不小心创建了一个全局变量 "),a("code",{pre:!0},[s._v("count")]),s._v("（第二章解释了这是 "),a("em",[s._v("如何")]),s._v(" 发生的！），而且它当前的值是 "),a("code",{pre:!0},[s._v("NaN")]),s._v("。当然，一旦他发现这个不寻常的结果后，他会有一堆其他的问题：“它怎么是全局的？为什么它是 "),a("code",{pre:!0},[s._v("NaN")]),s._v(" 而不是某个正确的计数值？”。（见第二章）")]),a("p",[s._v("与停在这里来深究为什么 "),a("code",{pre:!0},[s._v("this")]),s._v(" 引用看起来不是如我们 "),a("em",[s._v("期待")]),s._v(" 的那样工作，并且回答那些尖锐且重要的问题相反，许多开发者简单地完全回避这个问题，转向一些其他的另类解决方法，比如创建另一个对象来持有 "),a("code",{pre:!0},[s._v("count")]),s._v(" 属性：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("num")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"foo: "')]),s._v(" + num );\n\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 追踪 `foo` 被调用了多少次")]),s._v("\n\tdata."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v("++;\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" data = {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-attr"}},[s._v("count")]),s._v(": "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v("\n};\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" i;\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("for")]),s._v(" (i="),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v("; i<"),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("10")]),s._v("; i++) {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" (i > "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("5")]),s._v(") {\n\t\t"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("( i );\n\t}\n}\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 6")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 7")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 8")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 9")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// `foo` 被调用了多少次？")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( data."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 4")]),s._v("\n")])]),a("p",[s._v("虽然这种方式“解决”了问题是事实，但不幸的是它简单地忽略了真正的问题 —— 缺乏对于 "),a("code",{pre:!0},[s._v("this")]),s._v(" 的含义和其工作方式上的理解 —— 反而退回到了一个他更加熟悉的机制的舒适区：词法作用域。")]),a("p",[a("strong",[s._v("注意：")]),s._v(" 词法作用域是一个完善且有用的机制；我不是在用任何方式贬低它的作用（参见本系列的 "),a("em",[s._v('"作用域与闭包"')]),s._v("）。但在如何使用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 这个问题上总是靠 "),a("em",[s._v("猜")]),s._v("，而且通常都猜 "),a("em",[s._v("错")]),s._v("，并不是一个退回到词法作用域，而且从不学习 "),a("em",[s._v("为什么")]),s._v(" "),a("code",{pre:!0},[s._v("this")]),s._v(" 不跟你合作的好理由。")]),a("p",[s._v("为了从函数对象内部引用它自己，一般来说通过 "),a("code",{pre:!0},[s._v("this")]),s._v(" 是不够的。你通常需要通过一个指向它的词法标识符（变量）得到函数对象的引用。")]),a("p",[s._v("考虑这两个函数：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v(") {\n\tfoo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" = "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("4")]),s._v("; "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// `foo` 引用它自己")]),s._v("\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[s._v("setTimeout")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v("){\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 匿名函数（没有名字）不能引用它自己")]),s._v("\n}, "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("10")]),s._v(" );\n")])]),a("p",[s._v("第一个函数，称为“命名函数”，"),a("code",{pre:!0},[s._v("foo")]),s._v(" 是一个引用，可以用于在它内部引用自己。")]),a("p",[s._v("但是在第二个例子中，传递给 "),a("code",{pre:!0},[s._v("setTimeout(..)")]),s._v(" 的回调函数没有名称标识符（所以被称为“匿名函数”），所以没有合适的办法引用函数对象自己。")]),a("p",[a("strong",[s._v("注意：")]),s._v(" 在函数中有一个老牌儿但是现在被废弃的，而且令人皱眉头的 "),a("code",{pre:!0},[s._v("arguments.callee")]),s._v(" 引用 "),a("em",[s._v("也")]),s._v(" 指向当前正在执行的函数的函数对象。这个引用通常是匿名函数在自己内部访问函数对象的唯一方法。然而，最佳的办法是完全避免使用匿名函数，至少是对于那些需要自引用的函数，而使用命名函数（表达式）。"),a("code",{pre:!0},[s._v("arguments.callee")]),s._v(" 已经被废弃而且不应该再使用。")]),a("p",[s._v("对于当前我们的例子来说，另一个 "),a("em",[s._v("好用的")]),s._v(" 解决方案是在每一个地方都使用 "),a("code",{pre:!0},[s._v("foo")]),s._v(" 标识符作为函数对象的引用，而根本不用"),a("code",{pre:!0},[s._v("this")]),s._v("：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("num")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"foo: "')]),s._v(" + num );\n\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 追踪 `foo` 被调用了多少次")]),s._v("\n\tfoo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v("++;\n}\n\nfoo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" = "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v(";\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" i;\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("for")]),s._v(" (i="),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v("; i<"),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("10")]),s._v("; i++) {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" (i > "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("5")]),s._v(") {\n\t\t"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("( i );\n\t}\n}\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 6")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 7")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 8")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 9")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// `foo` 被调用了多少次？")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( foo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 4")]),s._v("\n")])]),a("p",[s._v("然而，这种方法也类似地回避了对 "),a("code",{pre:!0},[s._v("this")]),s._v(" 的 "),a("em",[s._v("真正")]),s._v(" 理解，而且完全依靠变量 "),a("code",{pre:!0},[s._v("foo")]),s._v(" 的词法作用域。")]),a("p",[s._v("另一种解决这个问题的方法是强迫 "),a("code",{pre:!0},[s._v("this")]),s._v(" 指向 "),a("code",{pre:!0},[s._v("foo")]),s._v(" 函数对象：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}},[s._v("num")]),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[s._v('"foo: "')]),s._v(" + num );\n\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 追踪 `foo` 被调用了多少次")]),s._v("\n\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 注意：由于 `foo` 的被调用方式（见下方），`this` 现在确实是 `foo`")]),s._v("\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v("++;\n}\n\nfoo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" = "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v(";\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" i;\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("for")]),s._v(" (i="),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("0")]),s._v("; i<"),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("10")]),s._v("; i++) {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("if")]),s._v(" (i > "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("5")]),s._v(") {\n\t\t"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 使用 `call(..)`，我们可以保证 `this` 指向函数对象(`foo`)")]),s._v("\n\t\tfoo."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("call")]),s._v("( foo, i );\n\t}\n}\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 6")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 7")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 8")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// foo: 9")]),s._v("\n\n"),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// `foo` 被调用了多少次？")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( foo."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("count")]),s._v(" ); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("// 4")]),s._v("\n")])]),a("p",[a("strong",[s._v("与回避 "),a("code",{pre:!0},[s._v("this")]),s._v(" 相反，我们接受它。")]),s._v(" 我们马上将会更完整地讲解这样的技术 "),a("em",[s._v("如何")]),s._v(" 工作，所以如果你依然有点儿糊涂，不要担心！")]),a("h3",[s._v("它的作用域")]),a("p",[s._v("对 "),a("code",{pre:!0},[s._v("this")]),s._v(" 的含义第二常见的误解，是它不知怎的指向了函数的作用域。这是一个刁钻的问题，因为在某一种意义上它有正确的部分，而在另外一种意义上，它是严重的误导。")]),a("p",[s._v("明确地说，"),a("code",{pre:!0},[s._v("this")]),s._v(" 不会以任何方式指向函数的 "),a("strong",[s._v("词法作用域")]),s._v("。作用域好像是一个将所有可用标识符作为属性的对象，这从内部来说是对的。但是 JavasScript 代码不能访问作用域“对象”。它是 "),a("em",[s._v("引擎")]),s._v(" 的内部实现。")]),a("p",[s._v("考虑下面代码，它（失败的）企图跨越这个边界，用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 来隐含地引用函数的词法作用域：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-js"}},[a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("var")]),s._v(" a = "),a("span",{pre:!0,attrs:{class:"hljs-number"}},[s._v("2")]),s._v(";\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("bar")]),s._v("();\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-keyword"}},[s._v("function")]),s._v(" "),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("bar")]),s._v("("),a("span",{pre:!0,attrs:{class:"hljs-params"}}),s._v(") {\n\t"),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("console")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("log")]),s._v("( "),a("span",{pre:!0,attrs:{class:"hljs-variable language_"}},[s._v("this")]),s._v("."),a("span",{pre:!0,attrs:{class:"hljs-property"}},[s._v("a")]),s._v(" );\n}\n\n"),a("span",{pre:!0,attrs:{class:"hljs-title function_"}},[s._v("foo")]),s._v("(); "),a("span",{pre:!0,attrs:{class:"hljs-comment"}},[s._v("//undefined")]),s._v("\n")])]),a("p",[s._v("这个代码段里不只有一个错误。虽然它看起来是在故意瞎搞，但你看到的这段代码，提取自在公共社区的帮助论坛中被交换的真实代码。真是难以想象对 "),a("code",{pre:!0},[s._v("this")]),s._v(" 的臆想是多么的误导人。")]),a("p",[s._v("首先，试图通过 "),a("code",{pre:!0},[s._v("this.bar()")]),s._v(" 来引用 "),a("code",{pre:!0},[s._v("bar()")]),s._v(" 函数。它几乎可以说是 "),a("em",[s._v("碰巧")]),s._v(" 能够工作，我们过一会儿再解释它是 "),a("em",[s._v("如何")]),s._v(" 工作的。调用 "),a("code",{pre:!0},[s._v("bar()")]),s._v(" 最自然的方式是省略开头的 "),a("code",{pre:!0},[s._v("this.")]),s._v("，而仅使用标识符进行词法引用。")]),a("p",[s._v("然而，写下这段代码的开发者试图用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 在 "),a("code",{pre:!0},[s._v("foo()")]),s._v(" 和 "),a("code",{pre:!0},[s._v("bar()")]),s._v(" 的词法作用域间建立一座桥，使得"),a("code",{pre:!0},[s._v("bar()")]),s._v(" 可以访问 "),a("code",{pre:!0},[s._v("foo()")]),s._v("内部作用域的变量 "),a("code",{pre:!0},[s._v("a")]),s._v("。"),a("strong",[s._v("这样的桥是不可能的。")]),s._v(" 你不能使用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 引用在词法作用域中查找东西。这是不可能的。")]),a("p",[s._v("每当你感觉自己正在试图使用 "),a("code",{pre:!0},[s._v("this")]),s._v(" 来进行词法作用域的查询时，提醒你自己："),a("em",[s._v("这里没有桥")]),s._v("。")]),a("h2",[s._v("什么是 "),a("code",{pre:!0},[s._v("this")]),s._v("？")]),a("p",[s._v("我们已经列举了各种不正确的臆想，现在让我们把注意力转移到 "),a("code",{pre:!0},[s._v("this")]),s._v(" 机制是如何真正工作的。")]),a("p",[s._v("我们早先说过，"),a("code",{pre:!0},[s._v("this")]),s._v(" 不是编写时绑定，而是运行时绑定。它依赖于函数调用的上下文条件。"),a("code",{pre:!0},[s._v("this")]),s._v(" 绑定与函数声明的位置没有任何关系，而与函数被调用的方式紧密相连。")]),a("p",[s._v("当一个函数被调用时，会建立一个称为执行环境的活动记录。这个记录包含函数是从何处（调用栈 —— call-stack）被调用的，函数是 "),a("em",[s._v("如何")]),s._v(" 被调用的，被传递了什么参数等信息。这个记录的属性之一，就是在函数执行期间将被使用的 "),a("code",{pre:!0},[s._v("this")]),s._v(" 引用。")]),a("p",[s._v("下一章中，我们将会学习寻找函数的 "),a("strong",[s._v("调用点（call-site）")]),s._v(" 来判定它的执行如何绑定 "),a("code",{pre:!0},[s._v("this")]),s._v("。")]),a("h2",[s._v("复习")]),a("p",[s._v("对于那些没有花时间学习 "),a("code",{pre:!0},[s._v("this")]),s._v(" 绑定机制如何工作的 JavaScript 开发者来说，"),a("code",{pre:!0},[s._v("this")]),s._v(" 绑定一直是困惑的根源。对于 "),a("code",{pre:!0},[s._v("this")]),s._v(" 这么重要的机制来说，猜测、试错、或者盲目地从 Stack Overflow 的回答中复制粘贴，都不是有效或正确利用它的方法。")]),a("p",[s._v("为了学习 "),a("code",{pre:!0},[s._v("this")]),s._v("，你必须首先学习 "),a("code",{pre:!0},[s._v("this")]),a("em",[s._v("不是")]),s._v(" 什么，不论是哪种把你误导至何处的臆测或误解。"),a("code",{pre:!0},[s._v("this")]),s._v(" 既不是函数自身的引用，也不是函数 "),a("em",[s._v("词法")]),s._v(" 作用域的引用。")]),a("p",[a("code",{pre:!0},[s._v("this")]),s._v(" 实际上是在函数被调用时建立的一个绑定，它指向 "),a("em",[s._v("什么")]),s._v(" 是完全由函数被调用的调用点来决定的。")])])])])}],!1,null,null,null);t.default=e.exports}}]);