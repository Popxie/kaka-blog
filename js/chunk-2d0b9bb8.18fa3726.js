(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d0b9bb8"],{"33ce":function(e,t,a){"use strict";a.r(t);var c=a("2877"),s=Object(c.a)({},(function(){var e=this;e.$createElement;return e._self._c,e._m(0)}),[function(){var e=this,t=e.$createElement,a=e._self._c||t;return a("section",[a("html",[a("head"),a("body",[a("h1",[e._v("Git 内部原理之 Git 对象")]),a("p",[a("strong",[e._v("从根本上来讲，Git 是一个内容寻址的文件系统，其次才是一个版本控制系统")]),e._v("。记住这点，对于理解 Git 的内部原理及其重要。所谓“内容寻址的文件系统”，意思是根据文件内容的 hash 码来定位文件。这就意味着同样内容的文件，在这个文件系统中会指向同一个位置，不会重复存储。")]),a("p",[e._v("Git 对象包含三种：数据对象、树对象、提交对象。Git 文件系统的设计思路与 linux 文件系统相似，即将文件的内容与文件的属性分开存储，文件内容以“装满字节的袋子”存储在文件系统中，文件名、所有者、权限等文件属性信息则另外开辟区域进行存储。在 Git 中，数据对象相当于文件内容，树对象相当于文件目录树，提交对象则是对文件系统的快照。")]),a("p",[e._v("下面的章节，会分别对每种对象进行说明。开始说明之前，先初始化一个 Git 文件系统：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("mkdir")]),e._v(" git-test\n$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("cd")]),e._v(" git-test\n$ git init\n")])]),a("p",[e._v("接下来的操作都会在 git-test 这个目录中进行。")]),a("h2",[e._v("数据对象")]),a("p",[e._v("数据对象是文件的内容，不包括文件名、权限等信息。Git 会根据文件内容计算出一个 hash 值，以 hash 值作为文件索引存储在 Git 文件系统中。由于相同的文件内容的 hash 值是一样的，因此 Git 将同样内容的文件只会存储一次。git "),a("code",{pre:!0},[e._v("hash-object")]),e._v(" 可以用来计算文件内容的 hash 值，并将生成的数据对象存储到 Git 文件系统中：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'version 1'")]),e._v(" | git hash-object -w --stdin\n83baae61804e65cc73a7201a7252750c76066a30\n\n$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'version 2'")]),e._v(" | git hash-object -w --stdin\n1f7a7a472abf3dd9643fd615f6da379c4acb3e3a\n\n$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'new file'")]),e._v(" | git hash-object -w --stdin\nfa49b077972391ad58037050f2a75f74e3671e92\n")])]),a("p",[e._v("上面示例中，"),a("code",{pre:!0},[e._v("-w")]),e._v(" 表示将数据对象写入到 Git 文件系统中，如果不加这个选项，那么只计算文件的 hash 值而不写入；"),a("code",{pre:!0},[e._v("--stdin")]),e._v(" 表示从标准输入中获取文件内容，当然也可以指定一个文件路径代替此选项。")]),a("p",[e._v("上面讲数据对象写入到 "),a("code",{pre:!0},[e._v("Git")]),e._v(" 文件系统中，那如何读取数据对象呢？"),a("code",{pre:!0},[e._v("git cat-file")]),e._v(" 可以用来实现所有 "),a("code",{pre:!0},[e._v("Git")]),e._v(" 对象的读取，包括数据对象、树对象、提交对象的查看：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p 83baae61804e65cc73a7201a7252750c76066a30\nversion 1\n\n$ git cat-file -t 83baae61804e65cc73a7201a7252750c76066a30\nblob\n")])]),a("p",[e._v("上面示例中，"),a("code",{pre:!0},[e._v("-p")]),e._v(" 表示查看 "),a("code",{pre:!0},[e._v("Git")]),e._v(" 对象的内容，"),a("code",{pre:!0},[e._v("-t")]),e._v(" 表示查看 Git 对象的类型。")]),a("p",[e._v("通过这一节，我们能够对 Git 文件系统中的数据对象进行读写。但是，我们需要记住每一个数据对象的 hash 值，才能访问到 Git 文件系统中的任意数据对象，这显然是不现实的。数据对象只是解决了文件内容存储的问题，而文件名的存储则需要通过下一节的树对象来解决。")]),a("h2",[e._v("树对象")]),a("p",[e._v("树对象是文件目录树，记录了文件获取目录的名称、类型、模式信息。使用 "),a("code",{pre:!0},[e._v("git update-index")]),e._v(" 可以为数据对象指定名称和模式，然后使用 "),a("code",{pre:!0},[e._v("git write-tree")]),e._v(" 将树对象写入到 Git 文件系统中：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git update-index --add --cacheinfo 100644 83baae61804e65cc73a7201a7252750c76066a30 test.txt\n$ git write-tree\nd8329fc1cc938780ffdd9f94e0d364e0ea74f579\n")])]),a("p",[a("code",{pre:!0},[e._v("--add")]),e._v(" 表示新增文件名，如果第一次添加某一文件名，必须使用此选项；"),a("code",{pre:!0},[e._v("--cacheinfo <mode> <object> <path>")]),e._v("是要添加的数据对象的模式、hash 值和路径，"),a("code",{pre:!0},[e._v("<path>")]),e._v("意味着为数据对象不仅可以指定单纯的文件名，也可以使用路径。另外要注意的是，使用 "),a("code",{pre:!0},[e._v("git update-index")]),e._v(" 添加完文件后，一定要使用 "),a("code",{pre:!0},[e._v("git write-tree")]),e._v(" 写入到 Git 文件系统中，否则只会存在于 index 区域。")]),a("p",[e._v("树对象仍然可以使用 "),a("code",{pre:!0},[e._v("git cat-file")]),e._v(" 查看：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n100644 blob 83baae61804e65cc73a7201a7252750c76066a30  test.txt\n\n$ git cat-file -t d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ntree\n")])]),a("p",[e._v("上面表示这个树对象只有 "),a("code",{pre:!0},[e._v("test.txt")]),e._v(" 这个文件，接下来我们将 version 2 的数据对象指定为 "),a("code",{pre:!0},[e._v("test.txt")]),e._v("，并添加一个新文件 "),a("code",{pre:!0},[e._v("new.txt")]),e._v("：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git update-index --cacheinfo 100644 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n$ git update-index --add --cacheinfo 100644 fa49b077972391ad58037050f2a75f74e3671e92 new.txt\n$ git write-tree\n0155eb4229851634a0f03eb265b69f5a2d56f341\n")])]),a("p",[e._v("查看树对象 0155eb，可以发现这个树对象有两个文件了：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p 0155eb4229851634a0f03eb265b69f5a2d56f341\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n")])]),a("p",[e._v("我们甚至可以使用 "),a("code",{pre:!0},[e._v("git read-tree")]),e._v("，将已添加的树对象读取出来，作为当前树的子树：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git read-tree --prefix=bak d8329fc1cc938780ffdd9f94e0d364e0ea74f579\n$ git write-tree\n3c4e9cd789d88d8d89c1073707c3585e41b0e614\n")])]),a("p",[a("code",{pre:!0},[e._v("--prefix")]),e._v(" 表示把子树对象放到哪个目录下。查看树对象，可以发现当前树对象有一个文件夹和两个文件：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p 3c4e9cd789d88d8d89c1073707c3585e41b0e614\n040000 tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579 bak\n100644 blob fa49b077972391ad58037050f2a75f74e3671e92 new.txt\n100644 blob 1f7a7a472abf3dd9643fd615f6da379c4acb3e3a test.txt\n")])]),a("p",[e._v("最终，整个树对象的结构如下图：")]),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/24952644/127742798-f72c7c60-1827-4484-951b-9678c5c5176d.png",alt:"31_Git内部原理之Git对象"}})]),a("p",[e._v("树对象解决了文件名的问题，而且，由于我们是分阶段提交树对象的，树对象可以看做是开发阶段源代码目录树的一次次快照，因此我们可以是用树对象作为源代码版本管理。但是，这里仍然有问题需要解决，即我们需要记住每个树对象的 hash 值，才能找到个阶段的源代码文件目录树。在源代码版本控制中，我们还需要知道谁提交了代码、什么时候提交的、提交的说明信息等，接下来的提交对象就是为了解决这个问题的。")]),a("h2",[e._v("提交对象")]),a("p",[e._v("提交对象是用来保存提交的作者、时间、说明这些信息的，可以使用 "),a("code",{pre:!0},[e._v("git commit-tree")]),e._v(" 来将提交对象写入到 Git 文件系统中：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'first commit'")]),e._v(" | git commit-tree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\ndb1d6f137952f2b24e3c85724ebd7528587a067a\n")])]),a("p",[e._v("上面 "),a("code",{pre:!0},[e._v("commit-tree")]),e._v(" 除了要指定提交的树对象，也要提供提交说明，至于提交的作者和时间，则是根据环境变量自动生成，并不需要指定。这里需要提醒一点的是，读者在测试时，得到的提交对象 hash 值一般和这里不一样，这是因为提交的作者和时间是因人而异的。")]),a("p",[e._v("提交对象的查看，也是使用 "),a("code",{pre:!0},[e._v("git cat-file")]),e._v("：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p db1d6f137952f2b24e3c85724ebd7528587a067a\ntree d8329fc1cc938780ffdd9f94e0d364e0ea74f579\nauthor jingsam <jing-sam@qq.com> 1528022503 +0800\ncommitter jingsam <jing-sam@qq.com> 1528022503 +0800\n\nfirst commit\n")])]),a("p",[e._v("上面是属于首次提交，那么接下来的提交还需要指定使用"),a("code",{pre:!0},[e._v("-p")]),e._v(" 指定父提交对象，这样代码版本才能成为一条时间线：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'second commit'")]),e._v(" | git commit-tree 0155eb4229851634a0f03eb265b69f5a2d56f341 -p db1d6f137952f2b24e3c85724ebd7528587a067a\nd4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\n")])]),a("p",[e._v("使用 "),a("code",{pre:!0},[e._v("git cat-file")]),e._v(" 查看一下新的提交对象，可以看到相比于第一次提交，多了 "),a("code",{pre:!0},[e._v("parent")]),e._v(" 部分：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git cat-file -p d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\ntree 0155eb4229851634a0f03eb265b69f5a2d56f341\nparent db1d6f137952f2b24e3c85724ebd7528587a067a\nauthor jingsam <jing-sam@qq.com> 1528022722 +0800\ncommitter jingsam <jing-sam@qq.com> 1528022722 +0800\n\nsecond commit\n")])]),a("p",[e._v("最后，我们再将树对象 3c4e9c 提交：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("echo")]),e._v(" "),a("span",{pre:!0,attrs:{class:"hljs-string"}},[e._v("'third commit'")]),e._v(" | git commit-tree 3c4e9cd789d88d8d89c1073707c3585e41b0e614 -p d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\n3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\n")])]),a("p",[e._v("使用 "),a("code",{pre:!0},[e._v("git log")]),e._v(" 可以查看整个提交历史：")]),a("pre",{pre:!0},[a("code",{pre:!0,attrs:{"v-pre":"",class:"language-bash"}},[e._v("$ git "),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("log")]),e._v(" --"),a("span",{pre:!0,attrs:{class:"hljs-built_in"}},[e._v("stat")]),e._v(" 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\ncommit 3ac728ac62f0a7b5ac201fd3ed1f69165df8be31\nAuthor: jingsam <jing-sam@qq.com>\nDate:   Sun Jun 3 18:47:29 2018 +0800\n\n  third commit\n\n bak/test.txt | 1 +\n 1 file changed, 1 insertion(+)\n\ncommit d4d2c6cffb408d978cb6f1eb6cfc70e977378a5c\nAuthor: jingsam <jing-sam@qq.com>\nDate:   Sun Jun 3 18:45:22 2018 +0800\n\n  second commit\n\n new.txt  | 1 +\n test.txt | 2 +-\n 2 files changed, 2 insertions(+), 1 deletion(-)\n\ncommit db1d6f137952f2b24e3c85724ebd7528587a067a\nAuthor: jingsam <jing-sam@qq.com>\nDate:   Sun Jun 3 18:41:43 2018 +0800\n\n  first commit\n\n test.txt | 1 +\n 1 file changed, 1 insertion(+)\n")])]),a("p",[e._v("最终的提交对象的结构如下图：")]),a("p",[a("img",{attrs:{src:"https://user-images.githubusercontent.com/24952644/127742739-30561d4b-0ae1-4278-b542-fb5b2fa0b822.png",alt:"32_Git内部原理之Git对象"}})]),a("h2",[e._v("总结")]),a("p",[e._v("Git 中的数据对象解决了数据存储的问题，树对象解决了文件名存储问题，提交对象解决了提交信息的存储问题。从 Git 设计中可以看出，Linus 对一个源代码版本控制系统做了很好的抽象和解耦，每种对象解决的问题都很明确，相比于使用一种数据结构，无疑更灵活和更易维护。")]),a("p",[a("a",{attrs:{href:"https://jingsam.github.io/2018/06/03/git-objects.html"}},[e._v("阅读原文")])])])])])}],!1,null,null,null);t.default=s.exports}}]);