(window.webpackJsonp=window.webpackJsonp||[]).push([["chunk-2d2266cd"],{e936:function(e,v,_){"use strict";_.r(v);var o=_("2877"),p=Object(o.a)({},(function(){var e=this;e.$createElement;return e._self._c,e._m(0)}),[function(){var e=this,v=e.$createElement,_=e._self._c||v;return _("section",[_("html",[_("head"),_("body",[_("h1",[e._v("面试题汇总")]),_("h2",[e._v("1.[腾讯二面]了解 v8 引擎吗，一段 js 代码如何执行的")]),_("ul",[_("li",[_("p",[e._v("在执行一段代码时，JS 引擎会首先创建一个"),_("strong",[e._v("执行栈")])])]),_("li",[_("p",[e._v("然后 JS 引擎会创建一个全局执行上下文，并 push 到执行栈中, 这个过程 JS 引擎会为这段代码中所有变量分配内存并赋一个初始值（undefined），在创建完成后，JS 引擎会进入"),_("strong",[e._v("执行阶段")]),e._v("，这个过程 JS 引擎会逐行的执行代码，即为之前分配好内存的变量逐个赋值(真实值)。")])]),_("li",[_("p",[e._v("如果这段代码中存在 function 的声明和调用，那么 JS 引擎会创建一个"),_("strong",[e._v("函数执行上下文")]),e._v("，并 push 到"),_("strong",[e._v("执行栈")]),e._v("中，其创建和执行过程跟全局执行上下文一样。但有特殊情况，即当函数中存在对其它函数的调用时，JS 引擎会在父函数执行的过程中，将子函数的全局执行上下文 push 到执行栈，这也是为什么子函数能够访问到父函数内所声明的变量。")])]),_("li",[_("p",[e._v("还有一种特殊情况是，在子函数执行的过程中，父函数已经 return 了，这种情况下，JS 引擎会将父函数的上下文从执行栈中移除，与此同时，JS 引擎会为还在执行的子函数上下文创建一个闭包，这个闭包里保存了父函数内声明的变量及其赋值，子函数仍然能够在其上下文中访问并使用这边变量/常量。当子函数执行完毕，JS 引擎才会将子函数的上下文及闭包一并从执行栈中移除。")])]),_("li",[_("p",[e._v("最后，JS 引擎是单线程的，那么它是如何处理高并发的呢？即当代码中存在异步调用时 JS 是如何执行的。比如 setTimeout 或 fetch 请求都是 non-blocking 的，当异步调用代码触发时，JS 引擎会将需要异步执行的代码移出调用栈，直到等待到返回结果，JS 引擎会立即将与之对应的回调函数 push 进任务队列中等待被调用，当调用(执行)栈中已经没有需要被执行的代码时，JS 引擎会立刻将任务队列中的回调函数逐个 push 进调用栈并执行。这个过程我们也称之为事件循环。")])])]),_("h2",[e._v("2.[未知]首屏和白屏时间如何计算？")]),_("p",[e._v("首屏时间的计算，可以由 "),_("code",{pre:!0},[e._v("Native WebView")]),e._v(" 提供的类似 "),_("code",{pre:!0},[e._v("onload")]),e._v(" 的方法实现，在 "),_("code",{pre:!0},[e._v("ios")]),e._v(" 下对应的是 "),_("code",{pre:!0},[e._v("webViewDidFinishLoad")]),e._v("，在 "),_("code",{pre:!0},[e._v("android")]),e._v(" 下对应的是 "),_("code",{pre:!0},[e._v("onPageFinished")]),e._v(" 事件。")]),_("p",[e._v("白屏的定义有多种。可以认为“没有任何内容”是白屏，可以认为“网络或服务异常”是白屏，可以认为“数据加载中”是白屏，可以认为“图片加载不出来”是白屏。场景不同，白屏的计算方式就不相同。")]),_("ul",[_("li",[e._v("方法 1：当页面的元素数小于 x 时，则认为页面白屏。比如“没有任何内容”，可以获取页面的 DOM 节点数，判断 DOM 节点数少于某个阈值 X，则认为白屏。")]),_("li",[e._v("方法 2：当页面出现业务定义的错误码时，则认为是白屏。比如“网络或服务异常”。")]),_("li",[e._v("方法 3：当页面出现业务定义的特征值时，则认为是白屏。比如“数据加载中”。")])]),_("h2",[e._v("3.[字节跳动] common.js 和 es6 中模块引入的区别？")]),_("p",[_("code",{pre:!0},[e._v("CommonJS")]),e._v(" 是一种模块规范，最初被应用于 "),_("code",{pre:!0},[e._v("Nodejs，成为")]),e._v(" "),_("code",{pre:!0},[e._v("Nodejs")]),e._v(" 的模块规范。运行在浏览器端的 "),_("code",{pre:!0},[e._v("JavaScript")]),e._v(" 由于也缺少类似的规范，在 "),_("code",{pre:!0},[e._v("ES6")]),e._v(" 出来之前，前端也实现了一套相同的模块规范 (例如: "),_("code",{pre:!0},[e._v("AMD")]),e._v(")，用来对前端模块进行管理。自 "),_("code",{pre:!0},[e._v("ES6")]),e._v(" 起，引入了一套新的 ES6 Module 规范，在语言标准的层面上实现了模块功能，而且实现得相当简单，有望成为浏览器和服务器通用的模块解决方案。但目前浏览器对 "),_("code",{pre:!0},[e._v("ES6 Module")]),e._v(" 兼容还不太好，我们平时在 "),_("code",{pre:!0},[e._v("Webpack")]),e._v(" 中使用的 "),_("code",{pre:!0},[e._v("export")]),e._v(" 和 "),_("code",{pre:!0},[e._v("import")]),e._v("，会经过 "),_("code",{pre:!0},[e._v("Babel")]),e._v(" 转换为 "),_("code",{pre:!0},[e._v("CommonJS")]),e._v(" 规范。在使用上的差别主要有：")]),_("ul",[_("li",[_("code",{pre:!0},[e._v("CommonJS")]),e._v(" 模块输出的是一个值的拷贝，"),_("code",{pre:!0},[e._v("ES6")]),e._v(" 模块输出的是值的引用。")]),_("li",[_("code",{pre:!0},[e._v("CommonJS")]),e._v(" 模块是运行时加载，"),_("code",{pre:!0},[e._v("ES6")]),e._v(" 模块是编译时输出接口。")]),_("li",[_("code",{pre:!0},[e._v("CommonJs")]),e._v(" 是单个值导出，"),_("code",{pre:!0},[e._v("ES6 Module")]),e._v(" 可以导出多个")]),_("li",[_("code",{pre:!0},[e._v("CommonJs")]),e._v(" 是动态语法可以写在判断里，"),_("code",{pre:!0},[e._v("ES6 Module")]),e._v(" 静态语法只能写在顶层")]),_("li",[_("code",{pre:!0},[e._v("CommonJs")]),e._v(" 的 "),_("code",{pre:!0},[e._v("this")]),e._v(" 是当前模块，"),_("code",{pre:!0},[e._v("ES6 Module")]),e._v(" 的 "),_("code",{pre:!0},[e._v("this")]),e._v(" 是 "),_("code",{pre:!0},[e._v("undefined")])])]),_("h2",[e._v("4.[腾讯一面]Virtual Dom 的优势在哪里？")]),_("p",[_("strong",[e._v("「Virtual Dom 的优势」")]),e._v(" 其实这道题目面试官更想听到的答案不是上来就说「直接操作/频繁操作 DOM 的性能差」，如果 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 操作的性能如此不堪，那么 "),_("code",{pre:!0},[e._v("jQuery")]),e._v(" 也不至于活到今天。所以面试官更想听到 "),_("code",{pre:!0},[e._v("VDOM")]),e._v(" 想解决的问题以及为什么频繁的 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 操作会性能差。")]),_("p",[e._v("首先我们需要知道：")]),_("p",[e._v("DOM 引擎、JS 引擎 相互独立，但又工作在同一线程（主线程） "),_("code",{pre:!0},[e._v("JS")]),e._v(" 代码调用 "),_("code",{pre:!0},[e._v("DOM API")]),e._v(" 必须 挂起 JS 引擎、转换传入参数数据、激活 DOM 引擎，DOM 重绘后再转换可能有的返回值，最后激活 JS 引擎并继续执行若有频繁的 "),_("code",{pre:!0},[e._v("DOM API")]),e._v(" 调用，且浏览器厂商不做“批量处理”优化， 引擎间切换的单位代价将迅速积累若其中有强制重绘的 "),_("code",{pre:!0},[e._v("DOM API")]),e._v(" 调用，重新计算布局、重新绘制图像会引起更大的性能消耗。")]),_("p",[e._v("其次是 "),_("code",{pre:!0},[e._v("VDOM")]),e._v(" 和真实 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 的区别和优化：")]),_("ul",[_("li",[e._v("虚拟 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 不会立马进行排版与重绘操作")]),_("li",[e._v("虚拟 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 进行频繁修改，然后一次性比较并修改真实 DOM 中需要改的部分，最后在真实 DOM 中进行排版与重绘，减少过多 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 节点排版与重绘损耗")]),_("li",[e._v("虚拟 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 有效降低大面积真实 DOM 的重绘与排版，因为最终与真实 "),_("code",{pre:!0},[e._v("DOM")]),e._v(" 比较差异，可以只渲染局部")])]),_("h2",[e._v("5.[高德一面]一个 tcp 连接能发几个 http 请求？")]),_("p",[e._v("如果是 "),_("code",{pre:!0},[e._v("HTTP 1.0")]),e._v(" 版本协议，一般情况下，不支持长连接，因此在每次请求发送完毕之后，TCP 连接即会断开，因此一个 "),_("code",{pre:!0},[e._v("TCP")]),e._v(" 发送一个 "),_("code",{pre:!0},[e._v("HTTP")]),e._v(" 请求，但是有一种情况可以将一条 TCP 连接保持在活跃状态，那就是通过 "),_("code",{pre:!0},[e._v("Connection")]),e._v(" 和 "),_("code",{pre:!0},[e._v("Keep-Alive")]),e._v(" 首部，在请求头带上 "),_("code",{pre:!0},[e._v("Connection")]),e._v(": "),_("code",{pre:!0},[e._v("Keep-Alive")]),e._v("，并且可以通过 "),_("code",{pre:!0},[e._v("Keep-Alive")]),e._v(" 通用首部中指定的，用逗号分隔的选项调节 "),_("code",{pre:!0},[e._v("keep-alive")]),e._v(" 的行为，如果客户端和服务端都支持，那么其实也可以发送多条，不过此方式也有限制，可以关注 "),_("strong",[e._v("《HTTP 权威指南》")]),e._v(" 4.5.5 节对于 "),_("code",{pre:!0},[e._v("Keep-Alive")]),e._v(" 连接的限制和规则。")]),_("p",[e._v("而如果是 "),_("code",{pre:!0},[e._v("HTTP 1.1")]),e._v(" 版本协议，支持了长连接，因此只要 "),_("code",{pre:!0},[e._v("TCP")]),e._v(" 连接不断开，便可以一直发送 "),_("code",{pre:!0},[e._v("HTTP")]),e._v(" 请求，持续不断，没有上限； 同样，如果是 "),_("code",{pre:!0},[e._v("HTTP 2.0")]),e._v(" 版本协议，支持多用复用，一个 TCP 连接是可以并发多个 HTTP 请求的，同样也是支持长连接，因此只要不断开 TCP 的连接，HTTP 请求数也是可以没有上限地持续发送")]),_("p",[_("a",{attrs:{href:"https://github.com/mqyqingfeng/frontend-interview-question-and-answer/issues/30"}},[e._v("阅读原文")])])])])])}],!1,null,null,null);v.default=p.exports}}]);